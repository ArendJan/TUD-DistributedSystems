---
title: "Byzantine Fault Tolerant Distributed Commit Protocol - Milestone 2: Implementation"
author: [Michael Leichtfried (5197171), TODO]
date: "2020-03-27"
subject: "Distributed Systems"
coursecode: "IN4391"
keywords: [distributed, commit protocol, atomic commit, byzantine]
lang: "en"
titlepage: "true"
titlepageTUDelft: "true"
papersize: "a4"
---

# Byzantine Distributed Commit Protocol Implementation
**IN4391 Distributed Systems - group 7**

We are Michael Leichtfried, Douwe Brinkhorst, Patrik Kron and Miguel Lucas, and we have implemented the system described in *"A Byzantine Fault Tolerant Distributed Commit Protocol"* by Wenbing Zhao (Department of Electrical and Computer Engineering, Cleveland State University).
## Introduction
In the paper the author describes a commit protocol for transactions which run over untrusted networks. The protocol consist of duplicating the coordinator and running a Byzantine agreement algorithm among the coordinator replicas. This protocol tolerates byzantine coordinator and faulty participant behaviour.
The Two Phase Commit (2PC) protocol addresses the issue of implementing a distributed commit protocol for distributed transactions, and different apporaches have been conducted in order to make it support byzantine behaviours. This paper's motivation was to improve these 2PC byzantine behaviour approaches.
A distributed transction is a transaction that is performed in multiple machines accross a computer network. The transaction is only commited if all operations succeed, and it is aborted if any operation fails.
## Distributed commit protocol  
According to 2PC protocol a distributed transaction contains one coordinator and some participants, but in the byzantine distributed commit protocol several coordinators are used. We have used the **akka** framework to implement coordinators and participants as actors since it simplifies dsitributed and concurrent application development. Actors communicate with each other through messages using the akka API. These messages are signed using public key technology so that no unidentified participant can interfere. It is assumend that there will exist *"3f + 1"* available coordinator replicas where "*f*" is the maximum number of byzantine coordinator replicas.
In the byzantine distributed commit protocol the original coordinator is called primary and coordinator copies receive the name of replicas. Every participant must register with the coordinator before the commit protocol starts. The commit protocol starts when a replica receives a commit request from a participant, which from now on will be called initiator. Now the coordinator replica sends a *"prepare"* request to every registered participant and waits until enought *"prepared"* messages are received from the participants. When *"prepared"* messages are received an instance of a *"Byzantine Agreement Algorithm"* is created. After reaching an agreement, coordinator replicas send  the agreement outcome to participants, which will only commit the transaction once *"f + 1"* simillar outcomes are received. This way at least one of the *"f + 1*" outcomes received comes from a non-byzantine replica.

## Byzantine Agreement Algorithm

## Objectives
We set objectives from the beginning in order to figure out and organise the work that had to be done. The objective list was divided into categories to state the priority of each objective.

- **Must have:** features the proyect must have in order to fulfill the basic requirements.
	- Implementation for coordinators.
	- Implementation for paticipants/initiators.
	- System testing infrastructure, including coordinator byzantine behaviour testing.
	
- **Should have/Could have**: features that might be implemented depending on time constraints.
	- Distributed deployment: test the system in multiple interconnected machines to simulate a realistic environment.
	- Message signing and signature checking.
	
- **Could have/Will not have**:
	- View change mechanism (this fetaure was not implemented by the paper authors either).
 

# About this report

The report for this assignment is written in Markdown (suggested editor: vscode). The final pdf-file can be generated by using pandoc and the provided template which is based on[eisvogel (Latex)](https://github.com/Wandmalfarbe/pandoc-latex-template). The command:

```
pandoc report.md -o report.pdf --from markdown --template .pandoc/templates/eisvogel.latex --listings
```
